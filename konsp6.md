# Некторые дополнительные сведения о массивах и указателей.

```c 
    int *p;
    int q[4];
    sizeof(q) // 16;
    sizeof(p) // не понятно
```
Узнать размер динамически выделенной памяти узнать невозможно. Статическую память можно узнать через `sizeof`. Мало памяти через `malloc` плохо, потому что он хранит еще доп информацию. 

Можно попросить напрямую выделить память, которая вернет указатель на начало. Но правило, чем память выделили, тем и освободили.

1. `malloc(size_t size)` — выделяет указанное количество байт и возвращает указатель на начало области.

2. `calloc(size_t num, size_t size)` — выделяет и инициализирует нулями память под массив.

3. `realloc(void* ptr, size_t new_size)` — изменяет размер ранее выделенной области.

4. `free(void* ptr) ` -- освобождает.

## Многомерные массивы и множественные указатели

```c

q[2][3]// -- некий двумерный массив 3*2;
```

В памяти же многомерный массив это последовательные значения -- непрерывная область памяти.

```c
    int **p; // массив указателей типа int
```
В памяти  это одномерный массив, который хранит указатели на массив `int`.
```c
    |0|->|int|.
    |1|->NULL
    |2|->|int|int|int|...
    ...

```
Строчка в си это указатель на место начала первого символа. `argv` - это, как раз массив указателей на строки.

Массив массивов это долго в обращении, но удобно при необходимости перестановок.

```c
p = malloc
p[0] == malloc
for 
    p[i] = p[i-1]+sizeof(...); 
    |
   \/ лучше чем
p = malloc
p* == malloc
for 
    p** = malloc.
```
## VMT
```c

int (*q)[w] = malloc(sizeof(int)*w*h)

тогда в функции
f(size_t w, size_t h, int (*q)[w] ~~ int q[][w])
```