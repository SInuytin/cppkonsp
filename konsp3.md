# Операции над типами в c/c++

все операции выполняются над одним типом.
(int) 1 + (float) 2 - невозможно, без конвертации(приведения).

| Арифметические | Логические | Побитовые |
| ----------- | ----------- | --- |
| `+` : сложение | `==`  : равно | `&` - побитовое и |
| `-` : вычитание | `!=`  : неравно | `\|` - побитовое или |
|  `*` : умножение | `<(<=)`  : меньше(меньше равно) | `^` - побитовое xor |
| `/` : деление | `>(>=)`  : больше(больше равно) | `<<` - битовый сдвиг влево|
| `%` : остаток | `&&` - and  | `>>` - битовый сдвиг вправо |
| | `\|\|` - or | |
| |  `!` - not | |

в си нет перегрузки операторов, а поэтому плюс всегда плюс.

## Базовые правила приведения

вместо плюса могут быть любые операции:

- float + int = float
- unsigned + signed = unsigned;
- short + int = int
- char + int = int

округление в си к нулю когда операции с целочисленными типами или  приведение из int -> float;

Деление это опасная операция, если $\dfrac{int}{0}$ - может что то получится, а может нихуя не получится, т.е undefined. Деление еще может привести к undefined есди поделить $\dfrac{int.minValue}{-1} > int.maxValue$ -> undefined behavior.
Так как остаток на уровне процессора та жа команда, что и деление то те же действия с остатком приводят к _undefined_.

В сравнение тоже может случиться хуйня если например signed < unsigned; Если размер одинаковый выбирается безнаковый и приводится к нему, если размеры разные выбирается больший.

```c
//прикол:
  unsigned int MAX_VALUE = -1; 
//это способ записи макс знач в безнаковый тип
```

### integer promotion

для типов меньше `int` приводит до `int`, для этого используется унарный плюс:

```c
short b = 40;
printf("%d",sizeof(+b))
//выведет  4 то есть short -> int;
```

---

Больше инфы на [cppreference.com](https://en.cppreference.com/w/)

## Undefined behavior в с

__undefined behavior__ это когда компилятор хз как это обрабатывать _de facto_ программа скомпилиться, но что будет по итогу никто, даже Аллах не знает.

Знаковое переполнение это неопределенная операция, хотя в железе оно может быть определено.

Переполнение в _unsigned_ это модулярная арифметика.

Модулярная арифметика(хз он повторяет это постоянно я хз что это)

## Операторы if/else

```c
if(0) - false;

if(1) - true // или что угодно, кроме 0
```

```c
if (условие)
    действие;// - внутри if
    действие;// - нет
if (условие) 
{
    действие;// - внутри if
    действие;//- тоже внутри
}
else действие 
или 
else {...} // блок

ТОЛЬКО ДЛЯ ПЛЮСОВ:
if(int x = f()) 
{
    //тут можно вызывать x
}
else
{
    // тут тоже можно
}
//тут нет
В СИ ТАК НЕЛЬЗЯ
```

При работе с `float` все, что `0.0` это `true`. Еще забавное:

```c
int a = (0 == 1);
int a = (0 == 0);
printf("a = %d, b = %d",a,b);
//вывод: a = 0; b = 1
```

## Булевы операции

Си гарантирует неполноту вычислений то есть:

```c
x && y / x// - гарантирует, что x не 0
```

Для всех остальных операций это не гарантируется $f(x) + g(x)$ - мы не знаем, что вычислиться первым $f$ или $g$, а в `&&` гарантируется, что сначала посчитается первой и если оно `false` aka `0`, то второй операнд даже не будет вычисляться.

В обще говоря си не гарантирует порядок вычисления вообще нихуя кроме булевых операций, но я не думаю, что это критично.

## Побитовые операции

```c
3 & 6 -> 2 // побитовое и
3 && 6 -> 1
```

Сдвиг направо `>>` и налево `<<`.

Сдвиги делятся на два класса логические и арифемтические, сдвиг налево всегда логический то есть биты двигаются влево, старший бит теряется младший превращается в ноль. А сдвиг направо может быть как арифметическим, когда младший переходит старший, а все остальные сдвигаются, так и логическим.

Когда тип `unsigned` то сдвиг логический, а иначе арифметический. ~~ой ебааный в рот какая залупа~~

Важно то насколько вы свдигаете, должно быть меньше размера переменной, то есть `int` можно `int << [0,31]` иначе будет _undefined behavior_

## Операция присвоение

```c
if(a=3) // выдаст 3 и warning при комплиции.
```

почти все бинарные операции объединить с присвоением:
> +=, -=, *=, &=. |=, \\=, %=, ^=

## Декременты инкременты

- a++ - сначала выдаст a, потом прибавит 1.
- ++a - сначала прибавит 1, а потом выдаст a.
- a-- - сначала выдаст a, потом вычтет 1.
- ++a - сначала вычтет 1, а потом выдаст a.

## Приоритет операций

у *,/ > +,- - это очевидно, но у других операций приоритет непонятен, если не уверены поставьте скобочки.

## Циклы

```c
while(условие)
    действие;

или

while(условие)
{
    много действий;
}

do 
    команда
while(условие);
или
do 
{
    команды;
}
while(условие);

break;// -- выход из цикла(самого внутренего)
continue; // -- переход на условие цикла
goto метка(метка на какой то строчки) // полезно если хочется сразу выйти из
// много циклов, но злоупотреблять не стоит

for (A; B; C)  
    D // блок или соло команда
//почти эквивалент
A;
while(B)
{
    D;
    C;
}
//разница в continue, в for -> C в while -> B
//любой части A,B,C может не быть
for(;;) ~~ while(true)
```

## Файловый ввод/ввывод

```c
scanf("%i,%i",&x,&y) // возвращает кол-во аргументов, что прочитанно
//читает y, если есть запятая после
// -1 закончился поток ввода
// 0 мне ввели, что то не то, все иное кол-во прочитанных перменных
//пробельные символы скипаются

printf(" x+y=%i\n", x+y)
```

`FILE *` - указатель(но это пока не важно), тип для работы файла.

```c
FILE * f = fopen("путь/к/файлу/имя","способ");
```

Способы `r` - чтение, `w` - запись, `rw` - чтение и запись, но это сложно не используем. `+b` - модификатор для работы с двоичными файлами.

```c
FILE * in = fopen("путь/к/файлу/имя","r");
fscanf(in,"%i,%i",&x,&y);  // на чтение
//тоже самое что и scanf, но первый аргумент, индификатор
printf(in," x+y=%i\n", x+y); // нихуя не будет

FILE * out = fopen("путь/к/файлу/имя","w"); //на запись
fscanf(out,"%i,%i",&x,&y); //тоже нихуя

fclose(in);
fclose(out);//закрываем файл, обязательно
```

`fopen` - возвращает `NULL`, если не получилось открыть по какой то причине.

```c
FILE * in = fopen("путь/к/файлу/имя","r");
if(!in) // проверка что открылся !in ~ in == NULL
{
    обработать ошибку
    return код ошибки;
}
```

в программе не должно быть утечек ресурсов.
